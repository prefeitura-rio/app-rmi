name: Deploy to Staging with Blue-Green

on:
  push:
    branches:
      - main

jobs:
  deploy-and-test:
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: write
      packages: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if k8s-only changes
        id: check-k8s-only
        run: |
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})

          # Check if only k8s/ files were changed
          NON_K8S_FILES=$(echo "$CHANGED_FILES" | grep -v "^k8s/" || true)

          if [ -z "$NON_K8S_FILES" ] && [ -n "$CHANGED_FILES" ]; then
            echo "k8s_only=true" >> $GITHUB_OUTPUT
            echo "Only k8s/ files changed, skipping build and tests"
          else
            echo "k8s_only=false" >> $GITHUB_OUTPUT
            echo "Non-k8s files changed, proceeding with build and tests"
          fi

      - name: Set up Go
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Install swag
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          mkdir -p bin
          GOBIN="$PWD/bin" go install github.com/swaggo/swag/cmd/swag@latest
          echo "$PWD/bin" >> $GITHUB_PATH

      - name: Generate Swagger documentation
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: swag init -g cmd/api/main.go

      - name: Set up Docker Buildx
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

      - name: Extract metadata for Docker
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        id: meta
        run: |
          COMMIT_HASH=${{ github.sha }}
          SHORT_HASH=$(git rev-parse --short HEAD)
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/app-rmi"

          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          echo "SHORT_HASH=$SHORT_HASH" >> $GITHUB_ENV

      - name: Build and Push Docker Image
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          docker buildx build \
            --platform linux/amd64 \
            --build-arg VERSION=$SHORT_HASH \
            --tag $IMAGE_NAME:latest \
            --tag $IMAGE_NAME:$COMMIT_HASH \
            --push .

      - name: Get image digest
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        id: digest
        run: |
          DIGEST=$(docker buildx imagetools inspect $IMAGE_NAME:latest --format '{{.Manifest.Digest}}' | grep -oE 'sha256:[a-f0-9]+' | head -n1)
          echo "DIGEST=$DIGEST" >> $GITHUB_ENV
          echo "Image digest: $DIGEST"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS_JSON }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }}

      - name: Install gke-gcloud-auth-plugin
        run: gcloud components install gke-gcloud-auth-plugin

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: latest

      - name: Install Argo Rollouts kubectl plugin
        run: |
          curl -fLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x ./kubectl-argo-rollouts-linux-amd64
          sudo mv ./kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Configure kubectl for GKE
        run: gcloud container clusters get-credentials application --zone=us-central1 --project="${{ vars.GCP_PROJECT_ID }}"

      - name: Update image in Git for ArgoCD
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          echo "Updating image in k8s/staging/resources.yaml..."

          # Update the image in the YAML file
          sed -i "s|image: ghcr.io/prefeitura-rio/app-rmi:.*|image: $IMAGE_NAME:$COMMIT_HASH@$DIGEST|g" k8s/staging/resources.yaml

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Commit and push to staging branch
          git add k8s/staging/resources.yaml
          git commit -m "chore(staging): update image to $COMMIT_HASH

          Automated image update from GitHub Actions deployment
          Image: $IMAGE_NAME:$COMMIT_HASH@$DIGEST

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"

          git push origin HEAD:staging

      - name: Wait for ArgoCD to sync
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          echo "Waiting for ArgoCD to sync the new image..."

          # Wait up to 2 minutes for ArgoCD to sync
          for i in {1..24}; do
            SYNC_STATUS=$(kubectl get application rmi -n argocd -o jsonpath='{.status.sync.status}')
            if [ "$SYNC_STATUS" == "Synced" ]; then
              echo "ArgoCD synced successfully"
              break
            fi
            if [ $i -eq 24 ]; then
              echo "Timeout waiting for ArgoCD sync"
              exit 1
            fi
            echo "Waiting for ArgoCD sync... (attempt $i/24)"
            sleep 5
          done

          # Wait for rollout to create preview
          kubectl argo rollouts status rmi -n rmi --timeout=5m

      - name: Set up port forward to preview service
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          echo "Setting up port forward to preview service..."
          # Start port-forward in background
          kubectl port-forward -n rmi service/rmi-preview 8080:80 &
          PORT_FORWARD_PID=$!
          echo "PORT_FORWARD_PID=$PORT_FORWARD_PID" >> $GITHUB_ENV

          # Wait for port-forward to be ready
          echo "Waiting for port-forward to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8080/v1/health > /dev/null 2>&1; then
              echo "Port-forward is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Port-forward failed to become ready"
              kill $PORT_FORWARD_PID 2>/dev/null || true
              exit 1
            fi
            echo "Attempt $i/30: Waiting for port-forward..."
            sleep 2
          done

      - name: Run E2E Tests Against Preview
        if: steps.check-k8s-only.outputs.k8s_only != 'true'
        env:
          TEST_BASE_URL: "http://localhost:8080/v1"
          TEST_KEYCLOAK_URL: ${{ secrets.TEST_KEYCLOAK_URL }}
          TEST_KEYCLOAK_REALM: ${{ secrets.TEST_KEYCLOAK_REALM }}
          TEST_KEYCLOAK_CLIENT_ID: ${{ secrets.TEST_KEYCLOAK_CLIENT_ID }}
          TEST_USERNAME: ${{ secrets.TEST_USERNAME }}
          TEST_PASSWORD: ${{ secrets.TEST_PASSWORD }}
          TEST_CPF: ${{ secrets.TEST_CPF }}
        run: |
          echo "Running E2E tests against preview service via port-forward..."
          go test -v ./tests/e2e/... -timeout 15m

      - name: Clean up port forward
        if: steps.check-k8s-only.outputs.k8s_only != 'true' && always()
        run: |
          echo "Cleaning up port-forward..."
          kill $PORT_FORWARD_PID 2>/dev/null || true

      - name: Promote to Stable
        if: steps.check-k8s-only.outputs.k8s_only != 'true' && success()
        run: |
          echo "‚úÖ Tests passed! Promoting to stable..."

          # Promote preview to active (stable)
          kubectl argo rollouts promote rmi -n rmi

          # Wait for promotion to complete
          kubectl argo rollouts status rmi -n rmi --timeout=5m

      - name: Rollback on Failure
        if: steps.check-k8s-only.outputs.k8s_only != 'true' && failure()
        run: |
          echo "‚ùå Tests failed! Aborting rollout..."

          # Abort the rollout (keeps stable service unchanged)
          kubectl argo rollouts abort rmi -n rmi

          echo "Rollout aborted. Preview discarded. Stable service unchanged."
          exit 1

      - name: Create deployment summary
        if: always() && steps.check-k8s-only.outputs.k8s_only != 'true'
        run: |
          echo "## üöÄ Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: $SHORT_HASH" >> $GITHUB_STEP_SUMMARY
          echo "**Image**: \`$IMAGE_NAME:$COMMIT_HASH@${DIGEST:0:12}...\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" = "success" ]; then
            echo "### ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "- Preview tests passed" >> $GITHUB_STEP_SUMMARY
            echo "- Promoted to active service" >> $GITHUB_STEP_SUMMARY
            echo "- Blue-green rollout complete" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "- E2E tests failed" >> $GITHUB_STEP_SUMMARY
            echo "- Rollout aborted" >> $GITHUB_STEP_SUMMARY
            echo "- Active service unchanged" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Comment on PR if exists
        if: always() && steps.check-k8s-only.outputs.k8s_only != 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) return;

            const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
            const message = `${status} **Staging Deployment ${status === '‚úÖ' ? 'Succeeded' : 'Failed'}**

            - **Commit**: \`${{ env.SHORT_HASH }}\`
            - **Image**: \`${{ env.IMAGE_NAME }}:${{ env.COMMIT_HASH }}@${{ env.DIGEST }}\`

            ${status === '‚úÖ' ?
              '- Preview tests passed\n- Promoted to active\n- Blue-green rollout complete' :
              '- E2E tests failed\n- Rollout aborted\n- Active unchanged'}
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: message
            });

      - name: Send Discord notification
        if: always() && steps.check-k8s-only.outputs.k8s_only != 'true'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "Discord webhook not configured, skipping notification"
            exit 0
          fi

          # Get commit info
          COMMIT_MSG=$(git log -1 --pretty=format:'%s' ${{ github.sha }})
          COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an' ${{ github.sha }})
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }}"

          # Determine status and color
          if [ "${{ job.status }}" = "success" ]; then
            STATUS_EMOJI="‚úÖ"
            STATUS_TEXT="Succeeded"
            COLOR="3066993"  # Green
            DESCRIPTION="Preview tests passed and deployment promoted to active service. Blue-green rollout complete."
          else
            STATUS_EMOJI="‚ùå"
            STATUS_TEXT="Failed"
            COLOR="15158332"  # Red
            DESCRIPTION="E2E tests failed. Rollout aborted. Active service unchanged."
          fi

          # Create Discord embed
          DISCORD_PAYLOAD=$(cat <<EOF
          {
            "embeds": [{
              "title": "${STATUS_EMOJI} Staging Deployment ${STATUS_TEXT}",
              "description": "${DESCRIPTION}",
              "color": ${COLOR},
              "fields": [
                {
                  "name": "üìù Commit",
                  "value": "[${COMMIT_MSG:0:50}](${COMMIT_URL})",
                  "inline": false
                },
                {
                  "name": "üë§ Author",
                  "value": "${COMMIT_AUTHOR}",
                  "inline": true
                },
                {
                  "name": "üîñ Version",
                  "value": "\`${SHORT_HASH}\`",
                  "inline": true
                },
                {
                  "name": "üê≥ Image",
                  "value": "\`${IMAGE_NAME}:${COMMIT_HASH}\`",
                  "inline": false
                }
              ],
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
              "footer": {
                "text": "GitHub Actions"
              }
            }]
          }
          EOF
          )

          # Send to Discord
          curl -H "Content-Type: application/json" \
               -d "$DISCORD_PAYLOAD" \
               "$DISCORD_WEBHOOK"
